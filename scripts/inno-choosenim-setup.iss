; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define AppName "choosenim"
#define AppNamePublisher "choosenim"
#define AppURL "https://github.com/dom96/choosenim"
#define AppExeName "choosenim.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{3092E256-6B81-42F6-A139-2C25B459D537}
AppName={#AppName}
AppVersion={code:GetVersion}
AppPublisher={#AppNamePublisher}
AppPublisherURL={#AppURL}
AppSupportURL={#AppURL}
AppUpdatesURL={#AppURL}
DefaultGroupName={#AppName}
CreateAppDir=no
DisableProgramGroupPage=yes
LicenseFile=..\LICENSE
OutputDir=..\bin
OutputBaseFilename=choosenim-setup
Compression=lzma
SolidCompression=yes
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Files]
Source: "..\bin\{#AppExeName}"; DestDir: "{%USERPROFILE}\.nimble\bin"; Flags: ignoreversion recursesubdirs createallsubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Tasks]
Name: InstallNim; Description: "Install latest Nim version."; Flags: unchecked

[Icons]
Name: "{group}\{cm:UninstallProgram,{#AppName}}"; Filename: "{uninstallexe}"

[UninstallDelete]
Type: filesandordirs; Name: "{%USERPROFILE}\.nimble"
Type: filesandordirs; Name: "{%USERPROFILE}\.choosenim"
Type: filesandordirs; Name: "{%USERPROFILE}\nimcache"

[Run]
Filename: "{%USERPROFILE}\.nimble\bin\{#AppExeName}"; Parameters: stable; StatusMsg: "Run choosenim to install Nim ..."; Flags: skipifsilent; Check: ShouldInstallNim

[Messages]
english.FinishedLabel=Setup has finished installing choosenim on your computer.

[Code]
const EnvironmentKey = 'Environment';
const NimbleFilePath = '..\choosenim.nimble';

function ShouldInstallNim: Boolean;
begin
  Result := WizardIsTaskSelected('InstallNim');
end;

procedure EnvAddPath(instlPath: string);
var
    Paths: string;
begin
    { Retrieve current path (use empty string if entry not exists) }
    if not RegQueryStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths) then
        Paths := '';

    if Paths = '' then
        Paths := instlPath + ';'
    else
    begin
        { Skip if string already found in path }
        if Pos(';' + Uppercase(instlPath) + ';',  ';' + Uppercase(Paths) + ';') > 0 then exit;
        if Pos(';' + Uppercase(instlPath) + '\;', ';' + Uppercase(Paths) + ';') > 0 then exit;

        { Append App Install Path to the end of the path variable }
        Log(Format('Right(Paths, 1): [%s]', [Paths[length(Paths)]]));
        if Paths[length(Paths)] = ';' then
            Paths := Paths + instlPath + ';'  { don't double up ';' in env(PATH) }
        else
            Paths := Paths + ';' + instlPath + ';' ;
    end;

    { Overwrite (or create if missing) path environment variable }
    if RegWriteStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths)
    then Log(Format('The [%s] added to PATH: [%s]', [instlPath, Paths]))
    else Log(Format('Error while adding the [%s] to PATH: [%s]', [instlPath, Paths]));
end;

procedure EnvRemovePath(instlPath: string);
var
    Paths: string;
    P, Offset, DelimLen: Integer;
begin
    { Skip if registry entry not exists }
    if not RegQueryStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths) then
        exit;

    { Skip if string not found in path }
    DelimLen := 1;     { Length(';') }
    P := Pos(';' + Uppercase(instlPath) + ';', ';' + Uppercase(Paths) + ';');
    if P = 0 then
    begin
        { perhaps instlPath lives in Paths, but terminated by '\;' }
        DelimLen := 2; { Length('\;') }
        P := Pos(';' + Uppercase(instlPath) + '\;', ';' + Uppercase(Paths) + ';');
        if P = 0 then exit;
    end;

    { Decide where to start string subset in Delete() operation. }
    if P = 1 then
        Offset := 0
    else
        Offset := 1;
    { Update path variable }
    Delete(Paths, P - Offset, Length(instlPath) + DelimLen);

    { Overwrite path environment variable }
    if RegWriteStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths)
    then Log(Format('The [%s] removed from PATH: [%s]', [instlPath, Paths]))
    else Log(Format('Error while removing the [%s] from PATH: [%s]', [instlPath, Paths]));
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
    if CurStep = ssPostInstall then
    begin
      EnvAddPath(ExpandConstant('{%USERPROFILE}') + '\.nimble\bin');
    end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
    if CurUninstallStep = usPostUninstall then
    begin
      EnvRemovePath(ExpandConstant('{%USERPROFILE}') + '\.nimble\bin');
    end;
end;

function GetVersion(Param: String): string;
var
  S: string;
  LineCount: Integer;
  SectionLine: Integer;    
  Lines: TArrayOfString;
begin
  Result := '';
  Log('start');
  if LoadStringsFromFile(NimbleFilePath, Lines) then
  begin
    Log('Loaded file');
    LineCount := GetArrayLength(Lines);
    for SectionLine := 0 to LineCount - 1 do
    begin
      Log('File line ' + lines[SectionLine] );

      if (pos('version       = ', Lines[SectionLine]) <> 0) then
      begin
        Log('version found');
        S := Trim(Lines[SectionLine]);
        StringChangeEx(S, '"', '', True);
        StringChangeEx(S, 'version       = ', '', True);
        StringChangeEx(S, '\\', '\', True);
        Result := S;
        Exit;
      end;
    end;
  end;
end;